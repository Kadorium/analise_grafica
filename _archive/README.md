# AI-Powered Trading Analysis System

A modular trading analysis system with a Python backend and HTML frontend that allows users to easily analyze stocks, implement technical indicators, backtest trading strategies, and optimize parameters without writing any code.

## üöÄ PROJECT OVERVIEW

**Name**: AI-Powered Trading Analysis System

**Purpose**: This system is designed to facilitate trading analysis for individuals, particularly non-programmers, by providing a user-friendly interface to upload data, apply technical indicators, select and customize trading strategies, run backtests, optimize parameters, and export results.

**Key Features**:
- **Data Loading & Cleaning**: Upload CSV files with historical stock data.
- **Technical Indicators**: Apply various indicators (Moving Averages, RSI, MACD, Bollinger Bands, etc.).
- **Trading Strategies**: Choose from pre-built strategies (Trend Following, Mean Reversion, Breakout, and more).
- **Backtesting Engine**: Test strategies against historical data.
- **Optimization**: Find the best parameters for your strategies.
- **User-Friendly Interface**: Control everything through an intuitive HTML interface.
- **Export Results**: Download analysis as PDF/Excel documents.
- **Configuration Management**: Save and load your analysis setups.

**Technologies Used**:
- **Python**: Core programming language for backend logic.
- **FastAPI**: Framework for building the backend API.
- **Pandas & NumPy**: Data manipulation and analysis.
- **Matplotlib & Seaborn**: Data visualization for charts and graphs.
- **Scikit-learn**: Machine learning components for optimization.
- **Chart.js**: Frontend library for rendering interactive charts.
- **HTML/CSS/JavaScript**: Frontend technologies for the user interface.

**Target Audience**: This system is primarily for non-programmers involved in trading analysis who need a straightforward way to analyze market data and test strategies via a graphical user interface, as well as developers or data scientists looking to extend trading algorithms.

## üóÇÔ∏è DIRECTORY STRUCTURE (DEEP LEVEL)

Below is the detailed folder hierarchy with explanations for each directory and key file:

- **`Analise_Grafica/`**: Root directory of the project.
  - **`_archive/`**: Contains archived or older versions of code and data.
    - **`debug/`**: Holds debugging-related files from past development.
  - **`app.py`**: Main backend application file using FastAPI. It defines API endpoints, serves the frontend, and orchestrates data processing, strategy application, and result generation.
  - **`backtesting/`**: Contains the backtesting engine logic.
    - **`backtester.py`**: Core backtesting class to simulate trading strategies on historical data, calculating performance metrics like returns and drawdowns.
  - **`config.py`**: Manages application configuration settings, providing default parameters for indicators, strategies, and backtesting.
  - **`data/`**: Manages data loading, storage, and preprocessing.
    - **`sample/`**: Contains sample CSV datasets for testing and demonstration purposes.
    - **`data_loader.py`**: Handles loading and cleaning of CSV data files, ensuring proper formatting for analysis.
  - **`frontend/`**: Houses all user interface files.
    - **`css/`**: Stylesheets for styling the HTML pages.
    - **`js/`**: JavaScript files for client-side logic and interactivity.
      - **`modules/`**: Organizes different JavaScript modules for specific functionalities.
      - **`utils/`**: Utility functions used across the frontend for common tasks.
  - **`indicators/`**: Contains implementations of technical indicators.
    - **`indicator_utils.py`**: Utility functions to combine and plot various indicators like Moving Averages, RSI, etc.
    - **Sub-modules**: Separate files for different indicator categories (e.g., `moving_averages.py`, `momentum.py`).
  - **`modularization project/`** and **`modularization_workspace/`**: Related to efforts in refactoring or modularizing the codebase, possibly experimental.
    - **`tracking/`** (in `modularization_workspace/`): May include tracking or logging mechanisms for modularization tasks.
      - **`instructions/`**: Documentation or scripts related to modularization instructions.
  - **`optimization/`**: Manages strategy parameter optimization.
    - **`optimizer.py`**: Implements grid search and other optimization techniques to find the best strategy parameters.
    - **`status.py`**: Tracks the status of optimization tasks.
    - **`charts.py`**, **`metrics.py`**, **`results.py`**: Handle visualization, metric calculation, and result storage for optimization.
  - **`results/`**: Stores outputs generated by the system.
    - **`configs/`**: Stores configuration files related to specific analysis runs.
    - **`optimization/`**: Contains detailed logs and outputs from optimization processes.
  - **`strategies/`**: Defines various trading strategies.
    - **`__init__.py`**: Registers all available strategies and provides a factory function to create strategy instances.
    - **Strategy Files**: Individual files for each strategy (e.g., `trend_following.py`, `mean_reversion.py`).
  - **`venv/`**: Python virtual environment directory (not for direct interaction).
  - **`requirements.txt`**: Lists all Python dependencies required to run the project.
  - **`start.py`**: A script to start the FastAPI backend server, with options to configure host, port, and auto-open a browser.
  - **`run_advanced_backtest.py`**: Script for executing advanced backtesting scenarios, allowing quick testing of strategies with minimal configuration.
  - **`.gitignore`**: Specifies files for Git to ignore (e.g., `__pycache__/`, `venv/`).
  - **`LICENSE`**: Contains the license information for the project.
  - **`optimization_requests.log`**: Log file for recording optimization requests and their status.
  - **Batch Scripts (`.bat`)**: Windows scripts like `clean_optimization_log.bat`, `run_advanced_backtest.bat`, `start.bat` for command-line operations.

## üß± ARCHITECTURE & DESIGN

**High-Level Architecture**:
- **Frontend-Backend Separation**: The system uses a client-server model where the frontend (HTML/CSS/JavaScript) is served by a FastAPI backend, communicating via RESTful API endpoints.
- **Client-Server Model**: The frontend runs in the user's browser, making asynchronous requests to the backend for data processing and receiving JSON responses.
- **Modular Backend Structure**: The backend is organized into distinct modules for data handling, indicators, strategies, backtesting, and optimization, promoting maintainability and scalability.

**Key Modules**:
- **`strategies`**: Defines trading strategies like Trend Following, Mean Reversion, and Breakout. It uses a registry to dynamically load strategies, allowing easy addition of new ones.
- **`indicators`**: Implements technical indicators (e.g., Moving Averages, RSI) that can be applied to data for analysis or strategy signals.
- **`backtesting`**: Provides the engine to simulate trading strategies on historical data, calculating performance metrics.
- **`optimization`**: Handles parameter optimization for strategies using techniques like grid search, running in parallel for efficiency.
- **`config`**: Manages configuration settings, allowing customization of parameters for indicators, strategies, and backtests.

**Textual Architecture Diagram**:

```
+-------------------+       +-------------------+       +-------------------+
|   User Interface  | <---> | FastAPI Backend   | <---> | Data Storage      |
| (HTML/CSS/JS)     |       | (app.py)          |       | (CSV, results/)   |
+-------------------+       +-------------------+       +-------------------+
                                    |
                                    v
+-------------------+       +-------------------+       +-------------------+
| Indicators        |       | Strategies        |       | Backtesting       |
| (indicators/)     |       | (strategies/)     |       | (backtesting/)    |
+-------------------+       +-------------------+       +-------------------+
                                    |
                                    v
+-------------------+       +-------------------+
| Optimization      |       | Configuration     |
| (optimization/)   |       | (config.py)       |
+-------------------+       +-------------------+
```

**Design Patterns**:
- **Factory Pattern**: Used in strategy creation (`strategies/__init__.py`) to instantiate strategy objects based on type.
- **Singleton Pattern**: Applied in configuration management (`config.py`) to ensure a single configuration instance across the application.
- **Adapter Pattern**: Used in `StrategyAdapter` class to make function-based strategies compatible with the backtesting engine.

## üîÑ BACKEND WORKFLOW EXPLAINED

**Core Analysis Workflow**:
1. **User Uploads CSV**: The user uploads a CSV file via the frontend interface (`/api/upload` endpoint). The backend (`data/data_loader.py`) loads and validates the data, ensuring required columns (Date, Open, High, Low, Close, Volume) are present.
2. **Data is Cleaned and Stored**: The `DataLoader` class cleans the data by handling missing values, converting column names to lowercase, and storing it in memory for further processing (`/api/process-data` endpoint).
3. **Indicators are Applied**: User-selected indicators are added to the data via `/api/add-indicators`. The `combine_indicators` function in `indicators/indicator_utils.py` applies indicators like Moving Averages or RSI based on configuration.
4. **Strategy Selected**: The user selects a strategy through `/api/run-backtest`. The backend uses a factory function (`create_strategy` in `strategies/__init__.py`) to instantiate the strategy with user-defined or default parameters.
5. **Backtest Runs**: The `Backtester` class (`backtesting/backtester.py`) simulates the strategy on the data, calculating positions, equity, and performance metrics like Sharpe Ratio and Max Drawdown.
6. **Metrics Calculated**: Performance metrics are computed within the `Backtester` or `StrategyAdapter` (`strategies/__init__.py`), providing detailed statistics on returns, win rate, etc.
7. **Results Exported**: Results are available via `/api/export-results/{format}` endpoint, allowing users to download reports in PDF or Excel format using libraries like `reportlab` and `openpyxl`.

**Optimization Workflow**:
- **Triggering Optimization**: Optimization is initiated via `/api/optimize-strategy` endpoint with a configuration specifying parameter ranges and target metric (e.g., Sharpe Ratio).
- **Under the Hood**: The `optimize_strategy` function in `optimization/optimizer.py` performs a grid search over parameter combinations, running backtests for each in parallel using `ProcessPoolExecutor`. Status is tracked via `optimization/status.py`, and results are saved using `optimization/results.py`.
- **Module Interactions**: `optimizer.py` coordinates with `strategies` for strategy execution, `backtesting` for simulation, `metrics.py` for performance evaluation, `charts.py` for visualization of optimization results, and `results.py` for storing outcomes.

## üì° FRONTEND-BACKEND INTEGRATION

- **UI to API Interaction**: The HTML/JavaScript frontend interacts with the FastAPI backend through RESTful endpoints defined in `app.py`. JavaScript uses `fetch` to make asynchronous HTTP requests for uploading data, applying indicators, running backtests, etc.
- **JSON Data Exchange**: Results from the backend are returned as JSON responses, which the frontend parses to update the UI dynamically, displaying charts, tables, or metrics.
- **Chart Rendering**: Charts are rendered on the frontend using Chart.js for interactive visualizations or saved as PNG images on the backend using Matplotlib for static exports.

## üß™ USAGE EXAMPLES

**Backtest Request/Response Flow**:
- **Request**: `POST /api/run-backtest` with JSON payload:
  ```json
  {
    "strategy_config": {
      "strategy_type": "trend_following",
      "parameters": { "fast_ma_period": 20, "slow_ma_period": 50 }
    },
    "backtest_config": { "initial_capital": 10000, "commission": 0.001 }
  }
  ```
- **Response**: JSON with performance metrics and signals:
  ```json
  {
    "strategy_name": "trend_following",
    "performance_metrics": {
      "total_return": 0.12,
      "sharpe_ratio": 1.5,
      "max_drawdown": 0.08
    },
    "signals": { ... }
  }
  ```

**Optimization Request/Response Flow**:
- **Request**: `POST /api/optimize-strategy` with configuration:
  ```json
  {
    "strategy_type": "mean_reversion",
    "param_ranges": {
      "rsi_period": [7, 14, 21],
      "oversold": [20, 30]
    },
    "metric": "sharpe_ratio"
  }
  ```
- **Response**: JSON with best parameters:
  ```json
  {
    "status": "completed",
    "best_params": { "rsi_period": 14, "oversold": 20 },
    "best_value": 1.8
  }
  ```

**Export Request/Response Flow**:
- **Request**: `GET /api/export-results/pdf`
- **Response**: File download of the results in PDF format.

**UI-Based Step-by-Step** (Existing, with minor expansion):
1. **Upload Data**: Click on the "Upload Data" tab, select your CSV file, click "Upload" and then "Process Data".
2. **Add Indicators**: Navigate to the "Indicators" tab, select desired indicators, set parameters, click "Apply Indicators", and view the chart.
3. **Choose a Strategy**: Go to the "Strategy" tab, select a trading strategy, customize parameters, click "Apply Strategy".
4. **Run Backtest**: In the "Backtest" tab, set initial capital and commission rate, click "Run Backtest", view performance metrics and trade history.
5. **Optimize Strategy (Optional)**: Navigate to the "Optimization" tab, set parameter ranges and optimization metric, click "Optimize Strategy", view and apply optimized parameters.
6. **Export Results**: Go to the "Results" tab, choose export format (PDF or Excel), click "Export".

## üõ†Ô∏è INSTALLATION & ENVIRONMENT

**Requirements**:
- **Python Version**: 3.8 or higher
- **Dependencies**: Listed in `requirements.txt`, including:
  - `fastapi==0.104.1`
  - `uvicorn==0.23.2`
  - `pandas==2.1.1`
  - `numpy==1.26.0`
  - `matplotlib==3.8.0`
  - And others (full list in `requirements.txt`)
- **Web Browser**: Chrome, Firefox, or Edge recommended.

**Installation Steps**:
1. Clone the repository:
   ```
   git clone <repository-url>
   cd trading-analysis-system
   ```
2. Create a virtual environment (recommended):
   ```
   # Windows
   python -m venv venv
   venv\Scripts\activate
   # macOS/Linux
   python -m venv venv
   source venv/bin/activate
   ```
3. Install dependencies:
   ```
   pip install -r requirements.txt
   ```

**Configuration Setup**:
- No `.env` file is required by default. Configuration can be managed via `config.py` for defaults or through the UI to save/load custom configurations to `results/configs/`.

## üì¶ DEPLOYMENT GUIDE

**Local Deployment**:
1. Start the application:
   ```
   # Using the provided script
   python start.py
   # Or directly with uvicorn
   python -m uvicorn app:app --reload
   ```
2. Open your browser and navigate to:
   ```
   http://localhost:8000
   ```

**Production Deployment**:
- **Using Gunicorn**: For a production environment, use Gunicorn with Uvicorn workers:
  ```
  gunicorn -w 4 -k uvicorn.workers.UvicornWorker app:app --bind 0.0.0.0:8000
  ```
- **Using Docker**: Containerize the application for easy deployment:
  1. Create a `Dockerfile`:
     ```dockerfile
     FROM python:3.9-slim
     WORKDIR /app
     COPY requirements.txt .
     RUN pip install -r requirements.txt
     COPY . .
     CMD ["gunicorn", "-w", "4", "-k", "uvicorn.workers.UvicornWorker", "app:app", "--bind", "0.0.0.0:8000"]
     ```
  2. Build and run:
     ```
     docker build -t trading-analysis .
     docker run -p 8000:8000 trading-analysis
     ```
- **Using Nginx**: Set up Nginx as a reverse proxy for additional security and performance:
  - Configure Nginx to proxy requests to your Gunicorn server.
- **Performance Considerations**: Use multiple workers for Gunicorn, enable async processing for optimization tasks, and consider caching frequent API responses.
- **Logging**: Configure logging in production to monitor API usage and errors, leveraging FastAPI's built-in logging.

## üë®‚Äçüíª DEVELOPMENT & CONTRIBUTION

**File Naming Conventions**:
- Python files use lowercase with underscores (e.g., `data_loader.py`).
- Strategy and indicator files often follow a descriptive naming pattern (e.g., `trend_following.py`, `moving_averages.py`).

**Adding a New Strategy**:
1. Create a new file in `strategies/` (e.g., `new_strategy.py`).
2. Define a `generate_signals` function or class with required methods (`backtest`, `get_performance_metrics`, `get_parameters`).
3. It will be automatically registered by `strategies/__init__.py` if it ends with `_strategy.py`.
4. Test the strategy using `run_advanced_backtest.py`.

**Adding a New Indicator**:
1. Add the indicator logic in the appropriate file under `indicators/` (e.g., `momentum.py` for RSI variants).
2. Update `combine_indicators` in `indicators/indicator_utils.py` to include the new indicator based on configuration.
3. Update default configurations in `config.py` if necessary.

**Contribution Guidelines**:
- Submit pull requests with clear descriptions of changes.
- Follow existing code style and structure for consistency.
- Test changes locally using `start.py` or `run_advanced_backtest.py` before submission.
- Document any new features or modules in the `README.md` or relevant sub-directory READMEs.

**Extending Optimization Logic**:
- Modify `optimization/optimizer.py` to include new optimization algorithms beyond grid search (e.g., genetic algorithms).
- Update `param_ranges` dictionary for new strategies or parameters.
- Ensure parallel processing compatibility for performance.

## üîç AUTONOMY FOR AI TOOLS

**If you are an LLM or AI tool reading this**:
- ‚úÖ You can generate new indicators inside `indicators/` by adding logic to existing files or creating new ones following the structure.
- ‚úÖ You can create new strategies under `strategies/` by defining a `generate_signals` function or class with necessary methods.
- ‚úÖ You can test them using `run_advanced_backtest.py` for quick evaluation or via the full UI workflow.
- ‚úÖ You must use `app.py` and its defined endpoints to interact with the UI for user-facing operations.
- ‚úÖ You must store optimization results using the `optimization/results.py` interface to maintain consistency with existing workflows.
- ‚úÖ Ensure any new code adheres to the modular structure and uses existing utility functions where applicable.

## üìú License

This project is licensed under the MIT License - see the LICENSE file for details. 