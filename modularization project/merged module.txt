# Comprehensive Frontend Modularization Plan

## Project Overview
This document outlines the detailed step-by-step process for modularizing the monolithic `app.js` file into multiple smaller, maintainable modules. The code will be refactored into a modern, modular JavaScript architecture that improves maintainability, testability, and collaboration.

## Initial Code Structure Analysis
Our analysis of app.js shows the following approximate sections:

| Line Range (approx.) | Section | Target Module |
|----------------------|---------|--------------|
| 1-60 | Initial setup, DOM references | main.js |
| 61-120 | Global variables, API endpoints | utils/api.js, utils/state.js |
| 121-200 | Utility functions | utils/ui.js, utils/formatters.js |
| 201-450 | Data upload and processing | modules/dataManager.js |
| 451-650 | Indicator management | modules/indicatorPanel.js |
| 651-950 | Strategy selections and parameters | modules/strategySelector.js |
| 951-1250 | Backtesting functionality | modules/backtestView.js |
| 1251-1550 | Optimization functionality | modules/optimizationPanel.js |
| 1551-1850 | Seasonality analysis | modules/seasonalityAnalyzer.js |
| 1851-2150 | Results handling and comparison | modules/resultsViewer.js |
| 2151-2300 | Configuration management | modules/configManager.js |
| 2301-end | App initialization and event listeners | main.js |

## Function Migration Checklist
As you migrate functions from app.js to their respective modules, check them off here:

- [ ] showError() → utils/ui.js
- [ ] showLoading() → utils/ui.js 
- [ ] formatDate() → utils/formatters.js
- [ ] formatNumber() → utils/formatters.js
- [ ] activateTab() → utils/ui.js
- [ ] updateDataPreview() → modules/dataManager.js
- [ ] uploadForm event handler → modules/dataManager.js
- [ ] arrangeBtn event handler → modules/dataManager.js
- [ ] fetchCurrentConfig() → modules/configManager.js
- [ ] buildStrategySelections() → modules/strategySelector.js
- [ ] loadStrategyParameters() → modules/strategySelector.js
- [ ] updateStrategyParameters() → modules/strategySelector.js
- [ ] formatParamName() → utils/formatters.js
- [ ] setupOptimizationParameters() → modules/optimizationPanel.js
- [ ] debugBacktestResults() → modules/backtestView.js
- [ ] runBacktest() → modules/backtestView.js
- [ ] displayBacktestResults() → modules/backtestView.js
- [ ] runOptimization() → modules/optimizationPanel.js
- [ ] checkOptimizationStatus() → modules/optimizationPanel.js
- [ ] fetchAndDisplayOptimizationResults() → modules/optimizationPanel.js
- [ ] compareStrategies() → modules/resultsViewer.js
- [ ] showSuccessMessage() → utils/ui.js
- [ ] updateIndicatorDropdowns() → modules/indicatorPanel.js
- [ ] moveSelectedOptions() → modules/indicatorPanel.js
- [ ] removeSelectedOptions() → modules/indicatorPanel.js
- [ ] checkDataStatus() → modules/dataManager.js
- [ ] formatMetricName() → utils/formatters.js
- [ ] formatMetricValue() → utils/formatters.js
- [ ] showGlobalLoader() → utils/ui.js
- [ ] hideGlobalLoader() → utils/ui.js
- [ ] showNotification() → utils/ui.js
- [ ] initializeIndicatorControls() → modules/indicatorPanel.js
- [ ] initializeSeasonalityControls() → modules/seasonalityAnalyzer.js
- [ ] runSeasonalityAnalysis() → modules/seasonalityAnalyzer.js
- [ ] displaySeasonalityResults() → modules/seasonalityAnalyzer.js
- [ ] updateCheckboxesFromAvailableIndicators() → modules/indicatorPanel.js

## Detailed Implementation Plan

### Phase 1: Setup and Preparation (1-2 days)

#### Step 1.1: Create Module Directory Structure
```bash
mkdir -p frontend/js/modules
mkdir -p frontend/js/utils
```

#### Step 1.2: Create Module Skeleton Files
```bash
# Create utility modules
touch frontend/js/utils/api.js
touch frontend/js/utils/ui.js
touch frontend/js/utils/formatters.js
touch frontend/js/utils/state.js

# Create feature modules
touch frontend/js/modules/dataManager.js
touch frontend/js/modules/indicatorPanel.js
touch frontend/js/modules/strategySelector.js
touch frontend/js/modules/backtestView.js
touch frontend/js/modules/optimizationPanel.js
touch frontend/js/modules/seasonalityAnalyzer.js
touch frontend/js/modules/resultsViewer.js
touch frontend/js/modules/configManager.js

# Create main entry point
touch frontend/js/main.js
```

#### Step 1.3: Backup Original Code
```bash
cp frontend/js/app.js frontend/js/app.js.backup
```

#### Checkpoint 1 - Verification
Before proceeding, verify that:
- [ ] All directories are created successfully
- [ ] All skeleton files exist
- [ ] Backup of app.js exists

### Phase 2: Create Utility Modules (2-3 days)

#### Step 2.1: Implement API Module (`utils/api.js`)

```javascript
// frontend/js/utils/api.js

// API endpoint definitions
export const API_BASE_URL = '';
export const API_ENDPOINTS = {
    UPLOAD: '/api/upload',
    PROCESS_DATA: '/api/process-data',
    ADD_INDICATORS: '/api/add-indicators',
    PLOT_INDICATORS: '/api/plot-indicators',
    AVAILABLE_STRATEGIES: '/api/available-strategies',
    STRATEGY_PARAMETERS: '/api/strategy-parameters',
    RUN_BACKTEST: '/api/run-backtest',
    OPTIMIZE_STRATEGY: '/api/optimize-strategy',
    OPTIMIZATION_STATUS: '/api/optimization-status',
    OPTIMIZATION_RESULTS: '/api/optimization-results',
    COMPARE_STRATEGIES: '/api/compare-strategies',
    SAVE_CONFIG: '/api/save-config',
    LOAD_CONFIG: '/api/load-config',
    EXPORT_RESULTS: '/api/export-results',
    CURRENT_CONFIG: '/api/current-config',
    ARRANGE_DATA: '/api/arrange-data',
    DATA_STATUS: '/api/data-status',
    SEASONALITY_DAY_OF_WEEK: '/api/seasonality/day-of-week',
    SEASONALITY_MONTHLY: '/api/seasonality/monthly',
    SEASONALITY_VOLATILITY: '/api/seasonality/volatility',
    SEASONALITY_HEATMAP: '/api/seasonality/heatmap',
    SEASONALITY_SUMMARY: '/api/seasonality/summary'
};

// Generic fetch wrapper with error handling
export async function fetchApi(endpoint, options = {}) {
    try {
        console.log(`API call to ${endpoint}`, options);
        const response = await fetch(endpoint, options);
        
        if (!response.ok) {
            const errorData = await response.json();
            throw new Error(errorData.message || `Error: ${response.status}`);
        }
        
        return await response.json();
    } catch (error) {
        console.error(`API error (${endpoint}):`, error);
        throw error;
    }
}

// Specific API call functions
export async function uploadData(formData) {
    return fetchApi(API_ENDPOINTS.UPLOAD, {
        method: 'POST',
        body: formData
    });
}

export async function processData() {
    return fetchApi(API_ENDPOINTS.PROCESS_DATA, {
        method: 'POST'
    });
}

export async function fetchDataStatus() {
    return fetchApi(API_ENDPOINTS.DATA_STATUS);
}

export async function addIndicators(indicatorConfig) {
    return fetchApi(API_ENDPOINTS.ADD_INDICATORS, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(indicatorConfig)
    });
}

export async function plotIndicators(plotConfig) {
    return fetchApi(API_ENDPOINTS.PLOT_INDICATORS, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(plotConfig)
    });
}

export async function fetchAvailableStrategies() {
    return fetchApi(API_ENDPOINTS.AVAILABLE_STRATEGIES);
}

export async function fetchStrategyParameters(strategyType) {
    return fetchApi(`${API_ENDPOINTS.STRATEGY_PARAMETERS}?type=${strategyType}`);
}

export async function runBacktest(requestData) {
    return fetchApi(API_ENDPOINTS.RUN_BACKTEST, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(requestData)
    });
}

export async function optimizeStrategy(requestData) {
    return fetchApi(API_ENDPOINTS.OPTIMIZE_STRATEGY, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(requestData)
    });
}

export async function checkOptimizationStatus() {
    return fetchApi(API_ENDPOINTS.OPTIMIZATION_STATUS);
}

export async function fetchOptimizationResults(strategyType) {
    return fetchApi(`${API_ENDPOINTS.OPTIMIZATION_RESULTS}/${strategyType}`);
}

export async function compareStrategies(requestData) {
    return fetchApi(API_ENDPOINTS.COMPARE_STRATEGIES, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(requestData)
    });
}

export async function saveConfig(configData) {
    return fetchApi(API_ENDPOINTS.SAVE_CONFIG, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(configData)
    });
}

export async function fetchCurrentConfig() {
    return fetchApi(API_ENDPOINTS.CURRENT_CONFIG);
}

export async function arrangeData(formData) {
    return fetchApi(API_ENDPOINTS.ARRANGE_DATA, {
        method: 'POST',
        body: formData
    });
}

export async function runSeasonalityAnalysis(analysisType) {
    const endpoint = API_ENDPOINTS[`SEASONALITY_${analysisType.toUpperCase().replace('-', '_')}`];
    return fetchApi(endpoint, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' }
    });
}
```

#### Step 2.2: Implement UI Module (`utils/ui.js`)

```javascript
// frontend/js/utils/ui.js

// Error handling
export function showError(message) {
    const errorModal = new bootstrap.Modal(document.getElementById('error-modal'));
    const errorMessage = document.getElementById('error-message');
    errorMessage.textContent = message;
    errorModal.show();
}

// Loading indicator
export function showLoading(element) {
    const spinnerHtml = `
        <div class="spinner-container">
            <div class="spinner-border text-primary spinner" role="status">
                <span class="visually-hidden">Loading...</span>
            </div>
        </div>
    `;
    element.innerHTML = spinnerHtml;
}

// Global loader
export function showGlobalLoader(message = 'Loading...') {
    let loaderEl = document.createElement('div');
    loaderEl.id = 'global-loader';
    loaderEl.className = 'position-fixed top-0 start-0 w-100 h-100 d-flex justify-content-center align-items-center bg-dark bg-opacity-50';
    loaderEl.style.zIndex = '9999';
    loaderEl.innerHTML = `
        <div class="bg-white p-3 rounded">
            <div class="d-flex align-items-center">
                <div class="spinner-border text-primary me-3"></div>
                <span>${message}</span>
            </div>
        </div>
    `;
    document.body.appendChild(loaderEl);
}

export function hideGlobalLoader() {
    const loader = document.getElementById('global-loader');
    if (loader) {
        loader.remove();
    }
}

// Success message
export function showSuccessMessage(message) {
    const successDiv = document.createElement('div');
    successDiv.className = 'alert alert-success alert-dismissible fade show mt-3';
    successDiv.innerHTML = `
        ${message}
        <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>
    `;
    
    // Find a good place to show the message
    const currentSection = document.querySelector('.content-section.active');
    if (currentSection) {
        currentSection.appendChild(successDiv);
        
        // Remove the message after 5 seconds
        setTimeout(() => {
            successDiv.remove();
        }, 5000);
    }
}

// Notification
export function showNotification(message, type = 'info') {
    // Create a Bootstrap alert
    const alertDiv = document.createElement('div');
    alertDiv.className = `alert alert-${type} alert-dismissible fade show`;
    alertDiv.setAttribute('role', 'alert');
    alertDiv.innerHTML = `
        ${message}
        <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>
    `;
    
    // Add to the current active section
    const currentSection = document.querySelector('.content-section.active');
    if (currentSection) {
        currentSection.prepend(alertDiv);
        
        // Auto dismiss after 5 seconds
        setTimeout(() => {
            alertDiv.remove();
        }, 5000);
    }
}

// Tab navigation
export function activateTab(tab, section, title) {
    // DOM elements
    const tabs = [
        document.getElementById('data-tab'),
        document.getElementById('indicators-tab'),
        document.getElementById('strategies-tab'),
        document.getElementById('backtest-tab'),
        document.getElementById('optimization-tab'),
        document.getElementById('seasonality-tab'),
        document.getElementById('results-tab')
    ];
    
    const sections = [
        document.getElementById('data-section'),
        document.getElementById('indicators-section'),
        document.getElementById('strategies-section'),
        document.getElementById('backtest-section'),
        document.getElementById('optimization-section'),
        document.getElementById('seasonality-section'),
        document.getElementById('results-section')
    ];
    
    const pageTitle = document.getElementById('page-title');
    
    // Deactivate all tabs and hide all sections
    tabs.forEach(t => {
        if (t) t.classList.remove('active');
    });
    
    sections.forEach(s => {
        if (s) s.classList.remove('active');
    });
    
    // Activate the selected tab and show the corresponding section
    if (tab) tab.classList.add('active');
    if (section) section.classList.add('active');
    if (pageTitle) pageTitle.textContent = title;
    
    // Save the active tab to session storage to persist across page reloads
    sessionStorage.setItem('activeTab', tab.id);
}
```

#### Step 2.3: Implement Formatters Module (`utils/formatters.js`)

```javascript
// frontend/js/utils/formatters.js

export function formatDate(dateStr) {
    if (!dateStr) return '';
    const date = new Date(dateStr);
    return date.toISOString().split('T')[0];
}

export function formatNumber(num, decimals = 2) {
    return Number(num).toFixed(decimals);
}

export function formatMetricName(metric) {
    // Convert snake_case to Title Case with spaces
    return metric
        .split('_')
        .map(word => word.charAt(0).toUpperCase() + word.slice(1))
        .join(' ');
}

export function formatMetricValue(metric, value) {
    if (typeof value === 'number') {
        // Format percentages with 2 decimal places
        if (metric.includes('return') || metric.includes('drawdown') || metric.includes('volatility') || metric.includes('rate')) {
            return value.toFixed(2) + '%';
        } 
        // Format ratios with 2 decimal places
        else if (metric.includes('ratio')) {
            return value.toFixed(2);
        }
        // Format other numbers with 2 decimal places
        return value.toFixed(2);
    }
    return value;
}

export function formatParamName(name) {
    return name
        .split('_')
        .map(word => word.charAt(0).toUpperCase() + word.slice(1))
        .join(' ');
}
```

#### Step 2.4: Implement State Module (`utils/state.js`)

```javascript
// frontend/js/utils/state.js

// Initialize application state
export const appState = {
    dataUploaded: false,
    dataProcessed: false,
    availableIndicators: [],
    selectedStrategy: 'trend_following',
    currentConfig: {},
    optimizationStatusInterval: null,
    currentOptimizationStrategy: null,
    
    // Methods to update state
    setDataUploaded(value) {
        this.dataUploaded = value;
        sessionStorage.setItem('dataUploaded', value);
    },
    
    setDataProcessed(value) {
        this.dataProcessed = value;
        sessionStorage.setItem('dataProcessed', value);
    },
    
    setAvailableIndicators(indicators) {
        this.availableIndicators = indicators;
    },
    
    setSelectedStrategy(strategy) {
        this.selectedStrategy = strategy;
    },
    
    setCurrentConfig(config) {
        this.currentConfig = config;
    },
    
    updateCurrentConfig(partialConfig) {
        this.currentConfig = { ...this.currentConfig, ...partialConfig };
    },
    
    // Restore state from session storage
    restoreFromSession() {
        if (sessionStorage.getItem('dataUploaded') === 'true') {
            this.dataUploaded = true;
        }
        
        if (sessionStorage.getItem('dataProcessed') === 'true') {
            this.dataProcessed = true;
        }
    }
};

// Initialize state from session storage
appState.restoreFromSession();
```

#### Checkpoint 2 - Verification
Before proceeding, verify that:
- [ ] All four utility modules have been implemented
- [ ] No utility functions remain in app.js
- [ ] Each module exports its functions properly
- [ ] No circular dependencies exist between utility modules

### Phase 3: Create Feature Modules (7-10 days)

#### Step 3.1: Implement DataManager Module (`modules/dataManager.js`)

```javascript
// frontend/js/modules/dataManager.js
import { uploadData, processData, fetchDataStatus, arrangeData as apiArrangeData } from '../utils/api.js';
import { showError, showLoading, showSuccessMessage, showGlobalLoader, hideGlobalLoader } from '../utils/ui.js';
import { appState } from '../utils/state.js';

export function updateDataPreview(data) {
    const dataInfo = document.getElementById('data-info');
    const dataPreview = document.getElementById('data-preview');
    
    dataInfo.innerHTML = `
        <p><strong>Rows:</strong> ${data.data_shape[0]} | <strong>Columns:</strong> ${data.data_shape[1]}</p>
        ${data.date_range ? `<p><strong>Date Range:</strong> ${data.date_range.start} to ${data.date_range.end}</p>` : ''}
    `;
    
    // Clear previous table data
    const thead = dataPreview.querySelector('thead tr');
    const tbody = dataPreview.querySelector('tbody');
    thead.innerHTML = '';
    tbody.innerHTML = '';
    
    if (data.data_sample && data.data_sample.length > 0) {
        // Add table headers
        Object.keys(data.data_sample[0]).forEach(header => {
            const th = document.createElement('th');
            th.textContent = header;
            thead.appendChild(th);
        });
        
        // Add table rows
        data.data_sample.forEach(row => {
            const tr = document.createElement('tr');
            
            Object.values(row).forEach(value => {
                const td = document.createElement('td');
                td.textContent = value;
                tr.appendChild(td);
            });
            
            tbody.appendChild(tr);
        });
    }
}

export async function uploadAndProcessData(formData) {
    try {
        // Get button reference
        const uploadProcessBtn = document.getElementById('upload-process-btn');
        uploadProcessBtn.disabled = true;
        uploadProcessBtn.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Uploading...';
        
        // Upload phase
        const uploadResponse = await uploadData(formData);
        
        // Update UI with data preview from upload
        updateDataPreview(uploadResponse);
        
        // Process phase
        uploadProcessBtn.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Processing...';
        
        const processResponse = await processData();
        
        // Update UI with processed data preview
        updateDataPreview(processResponse);
        
        // Update app state
        appState.setDataUploaded(true);
        appState.setDataProcessed(true);
        
        // Show success message
        const dataInfo = document.getElementById('data-info');
        dataInfo.innerHTML += `<div class="alert alert-success mt-2">Data uploaded and processed successfully!</div>`;
        
    } catch (error) {
        showError(error.message);
    } finally {
        const uploadProcessBtn = document.getElementById('upload-process-btn');
        uploadProcessBtn.disabled = false;
        uploadProcessBtn.textContent = 'Upload and Process';
    }
}

export async function arrangeData(fileInput) {
    if (!fileInput.files.length) {
        showError('Please select a file to arrange.');
        return;
    }
    
    const file = fileInput.files[0];
    const formData = new FormData();
    formData.append('file', file);
    
    try {
        const arrangeBtn = document.getElementById('arrange-btn');
        arrangeBtn.disabled = true;
        arrangeBtn.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Arranging...';
        
        // Call the API
        const data = await apiArrangeData(formData);
        
        // Update UI with arranged data preview
        updateDataPreview(data);
        
        // Update app state
        appState.setDataUploaded(true);
        appState.setDataProcessed(true);
        
        // Show success message
        const dataInfo = document.getElementById('data-info');
        dataInfo.innerHTML += `<div class="alert alert-success mt-2">Data arranged successfully! Saved to ${data.output_file}</div>`;
        
    } catch (error) {
        showError(error.message);
    } finally {
        const arrangeBtn = document.getElementById('arrange-btn');
        arrangeBtn.disabled = false;
        arrangeBtn.textContent = 'Arrange Data';
    }
}

export async function checkDataStatus() {
    try {
        const response = await fetchDataStatus();
        
        console.log('Backend data status:', response);
        
        // Update app state based on backend status
        if (response.uploaded) {
            appState.setDataUploaded(true);
        }
        
        if (response.processed) {
            appState.setDataProcessed(true);
        }
        
        return response;
    } catch (error) {
        console.error('Error checking data status:', error);
        return { uploaded: false, processed: false };
    }
}

export function initDataManager() {
    // Set up event listeners
    const uploadForm = document.getElementById('upload-form');
    if (uploadForm) {
        uploadForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            
            const fileInput = document.getElementById('csv-file');
            const formData = new FormData();
            
            if (fileInput.files.length > 0) {
                formData.append('file', fileInput.files[0]);
            } else {
                formData.append('file', '');
            }
            
            await uploadAndProcessData(formData);
        });
    }
    
    const arrangeBtn = document.getElementById('arrange-btn');
    if (arrangeBtn) {
        arrangeBtn.addEventListener('click', async () => {
            const fileInput = document.getElementById('csv-file');
            await arrangeData(fileInput);
        });
    }
}
```

#### Step 3.2: Implement IndicatorPanel Module (`modules/indicatorPanel.js`)

```javascript
// frontend/js/modules/indicatorPanel.js
import { addIndicators, plotIndicators } from '../utils/api.js';
import { showError, showSuccessMessage, showGlobalLoader, hideGlobalLoader } from '../utils/ui.js';
import { appState } from '../utils/state.js';

export function updateIndicatorDropdowns() {
    const mainIndicatorsSelect = document.getElementById('main-indicators');
    const subplotIndicatorsSelect = document.getElementById('subplot-indicators');
    
    // Clear existing options
    mainIndicatorsSelect.innerHTML = '';
    subplotIndicatorsSelect.innerHTML = '';
    
    // Add options for available indicators
    if (Array.isArray(appState.availableIndicators)) {
        appState.availableIndicators.forEach(indicator => {
            const mainOption = document.createElement('option');
            mainOption.value = indicator;
            mainOption.textContent = indicator;
            mainIndicatorsSelect.appendChild(mainOption);
            
            const subOption = document.createElement('option');
            subOption.value = indicator;
            subOption.textContent = indicator;
            subplotIndicatorsSelect.appendChild(subOption);
        });
    }
}

export function moveSelectedOptions(sourceId, targetId) {
    const sourceSelect = document.getElementById(sourceId);
    const targetSelect = document.getElementById(targetId);
    
    // Get selected options and move them
    Array.from(sourceSelect.selectedOptions).forEach(option => {
        const newOption = document.createElement('option');
        newOption.value = option.value;
        newOption.textContent = option.textContent;
        targetSelect.appendChild(newOption);
    });
    
    // Remove the selected options from source
    Array.from(sourceSelect.selectedOptions)
        .forEach(option => option.remove());
}

export function removeSelectedOptions(selectId) {
    const select = document.getElementById(selectId);
    
    // Remove selected options
    Array.from(select.selectedOptions)
        .forEach(option => option.remove());
}

export function updateCheckboxesFromAvailableIndicators() {
    const candlestickPatternsContainer = document.getElementById('candlestick-patterns-container');
    if (!candlestickPatternsContainer) return;
    
    // Clear existing checkboxes
    candlestickPatternsContainer.innerHTML = '';
    
    // Filter candlestick pattern indicators
    const patternIndicators = appState.availableIndicators.filter(ind => 
        ind.startsWith('CDL') || ind.startsWith('candlestick_')
    );
    
    // If no patterns found, hide container
    if (patternIndicators.length === 0) {
        document.getElementById('candlestick-patterns-section').style.display = 'none';
        return;
    }
    
    // Show container and create checkboxes
    document.getElementById('candlestick-patterns-section').style.display = 'block';
    
    patternIndicators.forEach(pattern => {
        const formCheck = document.createElement('div');
        formCheck.className = 'form-check';
        
        const input = document.createElement('input');
        input.className = 'form-check-input pattern-checkbox';
        input.type = 'checkbox';
        input.id = `pattern-${pattern}`;
        input.value = pattern;
        
        const label = document.createElement('label');
        label.className = 'form-check-label';
        label.htmlFor = `pattern-${pattern}`;
        label.textContent = pattern.replace('CDL', '').replace('candlestick_', '');
        
        formCheck.appendChild(input);
        formCheck.appendChild(label);
        candlestickPatternsContainer.appendChild(formCheck);
    });
}

export async function addIndicatorsToData() {
    // Get selected technical indicators
    const technicalIndicators = Array.from(
        document.querySelectorAll('#technical-indicators-container input:checked')
    ).map(cb => cb.value);
    
    // Get selected candlestick patterns
    const patternCheckboxes = document.querySelectorAll('.pattern-checkbox:checked');
    const candlestickPatterns = Array.from(patternCheckboxes).map(cb => cb.value);
    
    // Combine indicators
    const selectedIndicators = [...technicalIndicators, ...candlestickPatterns];
    
    if (selectedIndicators.length === 0) {
        showError('Please select at least one indicator.');
        return;
    }
    
    try {
        showGlobalLoader('Adding indicators...');
        
        const response = await addIndicators({
            indicators: selectedIndicators
        });
        
        // Update available indicators in app state
        appState.setAvailableIndicators(response.available_indicators || []);
        
        // Update UI dropdowns
        updateIndicatorDropdowns();
        
        // Show success
        showSuccessMessage('Indicators added successfully!');
        
    } catch (error) {
        showError(error.message);
    } finally {
        hideGlobalLoader();
    }
}

export async function plotChart() {
    // Get selected main chart indicators
    const mainIndicators = Array.from(document.getElementById('main-indicators').options).map(opt => opt.value);
    
    // Get selected subplot indicators
    const subplotIndicators = Array.from(document.getElementById('subplot-indicators').options).map(opt => opt.value);
    
    if (mainIndicators.length === 0 && subplotIndicators.length === 0) {
        showError('Please select at least one indicator to plot.');
        return;
    }
    
    try {
        showGlobalLoader('Generating chart...');
        
        const chartContainer = document.getElementById('chart-container');
        
        const response = await plotIndicators({
            main_indicators: mainIndicators,
            subplot_indicators: subplotIndicators
        });
        
        // Display the chart
        if (response.chart_html) {
            chartContainer.innerHTML = response.chart_html;
            
            // Make sure the chart is visible
            chartContainer.style.display = 'block';
            
            // Scroll to chart
            chartContainer.scrollIntoView({ behavior: 'smooth' });
        } else {
            showError('Failed to generate chart.');
        }
        
    } catch (error) {
        showError(error.message);
    } finally {
        hideGlobalLoader();
    }
}

export function initIndicatorControls() {
    // Add event listeners for indicator control buttons
    document.getElementById('move-to-main').addEventListener('click', function() {
        moveSelectedOptions('subplot-indicators', 'main-indicators');
    });
    
    document.getElementById('move-to-subplot').addEventListener('click', function() {
        moveSelectedOptions('main-indicators', 'subplot-indicators');
    });
    
    document.getElementById('remove-main').addEventListener('click', function() {
        removeSelectedOptions('main-indicators');
    });
    
    document.getElementById('remove-subplot').addEventListener('click', function() {
        removeSelectedOptions('subplot-indicators');
    });
    
    // Initialize candlestick pattern master checkbox control
    const candlestickPatternsCheckbox = document.getElementById('candlestick-patterns-checkbox');
    if (candlestickPatternsCheckbox) {
        candlestickPatternsCheckbox.addEventListener('change', function() {
            const patternCheckboxes = document.querySelectorAll('.pattern-checkbox');
            patternCheckboxes.forEach(cb => {
                cb.checked = candlestickPatternsCheckbox.checked;
            });
        });
    }
}

export function initIndicatorPanel() {
    // Set up event listeners for forms
    const indicatorsForm = document.getElementById('indicators-form');
    if (indicatorsForm) {
        indicatorsForm.addEventListener('submit', (e) => {
            e.preventDefault();
            addIndicatorsToData();
        });
    }
    
    const chartForm = document.getElementById('chart-form');
    if (chartForm) {
        chartForm.addEventListener('submit', (e) => {
            e.preventDefault();
            plotChart();
        });
    }
    
    // Initialize controls
    initIndicatorControls();
}
```

#### Step 3.3: Implement StrategySelector Module (`modules/strategySelector.js`)

```javascript
// frontend/js/modules/strategySelector.js
import { fetchAvailableStrategies, fetchStrategyParameters } from '../utils/api.js';
import { showError, showSuccessMessage, showGlobalLoader, hideGlobalLoader } from '../utils/ui.js';
import { formatParamName } from '../utils/formatters.js';
import { appState } from '../utils/state.js';

export function buildStrategySelections(container, strategies, selectedClass = 'selected-strategy') {
    // Clear the container
    container.innerHTML = '';
    
    // Create buttons for each strategy
    strategies.forEach(strategy => {
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = 'btn btn-outline-primary strategy-btn me-2 mb-2';
        btn.dataset.strategy = strategy.id;
        btn.textContent = strategy.name;
        
        // Set active state if this is the currently selected strategy
        if (strategy.id === appState.selectedStrategy) {
            btn.classList.add(selectedClass);
        }
        
        // Add click event
        btn.addEventListener('click', function() {
            // Remove active class from all buttons
            container.querySelectorAll('.strategy-btn').forEach(b => {
                b.classList.remove(selectedClass);
            });
            
            // Add active class to clicked button
            this.classList.add(selectedClass);
            
            // Update selected strategy in app state
            appState.setSelectedStrategy(strategy.id);
            
            // Load parameters for selected strategy
            updateStrategyParameters(strategy.id);
        });
        
        container.appendChild(btn);
    });
}

export async function loadStrategyParameters() {
    try {
        showGlobalLoader('Loading strategies...');
        
        // Get the strategy type from dropdown
        const strategyType = document.getElementById('strategy-type').value;
        
        // Fetch available strategies for this type
        const response = await fetchAvailableStrategies();
        
        // Filter strategies by type
        const typeStrategies = response.strategies.filter(s => s.type === strategyType);
        
        // Build strategy selection buttons
        const strategyContainer = document.getElementById('strategy-selection');
        buildStrategySelections(strategyContainer, typeStrategies);
        
        // Select first strategy by default if none selected
        if (!appState.selectedStrategy && typeStrategies.length > 0) {
            appState.setSelectedStrategy(typeStrategies[0].id);
        }
        
        // Load parameters for the selected strategy
        await updateStrategyParameters(appState.selectedStrategy);
        
    } catch (error) {
        showError(error.message);
    } finally {
        hideGlobalLoader();
    }
}

export async function updateStrategyParameters(strategyType) {
    if (!strategyType) return;
    
    try {
        const paramsContainer = document.getElementById('strategy-parameters');
        showGlobalLoader('Loading parameters...');
        
        // Clear existing parameters
        paramsContainer.innerHTML = '';
        
        // Fetch parameters for the selected strategy
        const response = await fetchStrategyParameters(strategyType);
        
        if (!response.parameters || response.parameters.length === 0) {
            paramsContainer.innerHTML = '<p>No parameters available for this strategy.</p>';
            return;
        }
        
        // Create form groups for each parameter
        response.parameters.forEach(param => {
            const formGroup = document.createElement('div');
            formGroup.className = 'mb-3';
            
            const label = document.createElement('label');
            label.className = 'form-label';
            label.htmlFor = `param-${param.name}`;
            label.textContent = formatParamName(param.name);
            
            let input;
            
            // Create different input types based on parameter type
            if (param.type === 'boolean') {
                // Create checkbox for boolean parameters
                input = document.createElement('div');
                input.className = 'form-check';
                
                const checkbox = document.createElement('input');
                checkbox.className = 'form-check-input';
                checkbox.type = 'checkbox';
                checkbox.id = `param-${param.name}`;
                checkbox.name = param.name;
                checkbox.checked = param.default === true;
                
                const checkLabel = document.createElement('label');
                checkLabel.className = 'form-check-label';
                checkLabel.htmlFor = `param-${param.name}`;
                checkLabel.textContent = formatParamName(param.name);
                
                input.appendChild(checkbox);
                input.appendChild(checkLabel);
                
                // We don't need the original label for checkboxes
                label.remove();
            } else if (param.type === 'select') {
                // Create select dropdown for options
                input = document.createElement('select');
                input.className = 'form-select';
                input.id = `param-${param.name}`;
                input.name = param.name;
                
                // Add options
                param.options.forEach(option => {
                    const opt = document.createElement('option');
                    opt.value = option;
                    opt.textContent = option;
                    if (option === param.default) {
                        opt.selected = true;
                    }
                    input.appendChild(opt);
                });
            } else {
                // Create text input for other parameter types
                input = document.createElement('input');
                input.className = 'form-control';
                input.type = param.type === 'number' ? 'number' : 'text';
                input.id = `param-${param.name}`;
                input.name = param.name;
                input.value = param.default !== undefined ? param.default : '';
                
                // Add min/max/step attributes for number inputs
                if (param.type === 'number') {
                    if (param.min !== undefined) input.min = param.min;
                    if (param.max !== undefined) input.max = param.max;
                    if (param.step !== undefined) input.step = param.step;
                }
            }
            
            // Add description if available
            if (param.description) {
                const helpText = document.createElement('div');
                helpText.className = 'form-text';
                helpText.textContent = param.description;
                formGroup.appendChild(label);
                formGroup.appendChild(input);
                formGroup.appendChild(helpText);
            } else {
                formGroup.appendChild(label);
                formGroup.appendChild(input);
            }
            
            paramsContainer.appendChild(formGroup);
        });
        
    } catch (error) {
        showError(error.message);
    } finally {
        hideGlobalLoader();
    }
}

export function initStrategySelector() {
    // Add event listener for strategy type change
    const strategyTypeSelect = document.getElementById('strategy-type');
    if (strategyTypeSelect) {
        strategyTypeSelect.addEventListener('change', loadStrategyParameters);
    }
    
    // Load strategy parameters initially
    loadStrategyParameters();
}
```

#### Step 3.4: Implement BacktestView Module (`modules/backtestView.js`)

```javascript
// frontend/js/modules/backtestView.js
import { runBacktest } from '../utils/api.js';
import { showError, showSuccessMessage, showGlobalLoader, hideGlobalLoader } from '../utils/ui.js';
import { formatMetricName, formatMetricValue } from '../utils/formatters.js';
import { appState } from '../utils/state.js';

export function debugBacktestResults(results) {
    console.log('Backtest Results:', results);
    // This function can be expanded with additional debugging features if needed
}

export async function runBacktest() {
    try {
        showGlobalLoader('Running backtest...');
        
        // Get form values
        const strategyType = appState.selectedStrategy;
        const startDate = document.getElementById('backtest-start-date').value;
        const endDate = document.getElementById('backtest-end-date').value;
        const initialCapital = parseFloat(document.getElementById('initial-capital').value);
        const positionSize = parseFloat(document.getElementById('position-size').value);
        
        // Validate inputs
        if (!strategyType) {
            throw new Error('Please select a strategy first.');
        }
        
        if (!startDate || !endDate) {
            throw new Error('Please provide both start and end dates.');
        }
        
        if (isNaN(initialCapital) || initialCapital <= 0) {
            throw new Error('Initial capital must be a positive number.');
        }
        
        if (isNaN(positionSize) || positionSize <= 0 || positionSize > 100) {
            throw new Error('Position size must be between 0 and 100.');
        }
        
        // Get strategy parameters
        const paramElements = document.querySelectorAll('#strategy-parameters [name]');
        const strategyParams = {};
        
        paramElements.forEach(element => {
            const paramName = element.name;
            let paramValue;
            
            if (element.type === 'checkbox') {
                paramValue = element.checked;
            } else if (element.type === 'number') {
                paramValue = parseFloat(element.value);
            } else {
                paramValue = element.value;
            }
            
            strategyParams[paramName] = paramValue;
        });
        
        // Build request data
        const requestData = {
            strategy_type: strategyType,
            start_date: startDate,
            end_date: endDate,
            initial_capital: initialCapital,
            position_size: positionSize / 100, // Convert percentage to decimal
            strategy_params: strategyParams
        };
        
        // Call the API
        const backtestResults = await runBacktest(requestData);
        
        // Display results
        displayBacktestResults(backtestResults);
        
        // For debugging
        debugBacktestResults(backtestResults);
        
        // Update app state with the backtest configuration
        appState.updateCurrentConfig({
            backtest: {
                strategy_type: strategyType,
                start_date: startDate,
                end_date: endDate,
                initial_capital: initialCapital,
                position_size: positionSize,
                strategy_params: strategyParams
            }
        });
        
    } catch (error) {
        showError(error.message);
    } finally {
        hideGlobalLoader();
    }
}

export function displayBacktestResults(results) {
    const resultsContainer = document.getElementById('backtest-results');
    
    // Clear previous results
    resultsContainer.innerHTML = '';
    
    // Create sections
    const performanceSection = document.createElement('div');
    performanceSection.className = 'card mb-4';
    performanceSection.innerHTML = `
        <div class="card-header">
            <h5 class="card-title mb-0">Performance Metrics</h5>
        </div>
        <div class="card-body">
            <div class="row" id="performance-metrics"></div>
        </div>
    `;
    
    const tradeSection = document.createElement('div');
    tradeSection.className = 'card mb-4';
    tradeSection.innerHTML = `
        <div class="card-header">
            <h5 class="card-title mb-0">Trade Statistics</h5>
        </div>
        <div class="card-body">
            <div class="row" id="trade-metrics"></div>
        </div>
    `;
    
    const equityCurveSection = document.createElement('div');
    equityCurveSection.className = 'card mb-4';
    equityCurveSection.innerHTML = `
        <div class="card-header">
            <h5 class="card-title mb-0">Equity Curve</h5>
        </div>
        <div class="card-body">
            <div id="equity-curve-chart"></div>
        </div>
    `;
    
    const tradesTableSection = document.createElement('div');
    tradesTableSection.className = 'card';
    tradesTableSection.innerHTML = `
        <div class="card-header">
            <h5 class="card-title mb-0">Trades</h5>
        </div>
        <div class="card-body">
            <div class="table-responsive">
                <table class="table table-striped" id="trades-table">
                    <thead>
                        <tr>
                            <th>Entry Date</th>
                            <th>Exit Date</th>
                            <th>Type</th>
                            <th>Entry Price</th>
                            <th>Exit Price</th>
                            <th>Size</th>
                            <th>P&L</th>
                            <th>P&L %</th>
                        </tr>
                    </thead>
                    <tbody>
                    </tbody>
                </table>
            </div>
        </div>
    `;
    
    // Add sections to the results container
    resultsContainer.appendChild(performanceSection);
    resultsContainer.appendChild(tradeSection);
    resultsContainer.appendChild(equityCurveSection);
    resultsContainer.appendChild(tradesTableSection);
    
    // Populate performance metrics
    const performanceMetricsContainer = document.getElementById('performance-metrics');
    
    const performanceMetrics = [
        'total_return', 'annualized_return', 'max_drawdown', 'volatility', 
        'sharpe_ratio', 'sortino_ratio', 'calmar_ratio', 'win_rate'
    ];
    
    performanceMetrics.forEach(metric => {
        if (results.metrics[metric] !== undefined) {
            const metricCard = document.createElement('div');
            metricCard.className = 'col-md-3 col-sm-6 mb-3';
            metricCard.innerHTML = `
                <div class="card h-100">
                    <div class="card-body text-center">
                        <h6 class="card-title">${formatMetricName(metric)}</h6>
                        <p class="display-6">${formatMetricValue(metric, results.metrics[metric])}</p>
                    </div>
                </div>
            `;
            performanceMetricsContainer.appendChild(metricCard);
        }
    });
    
    // Populate trade metrics
    const tradeMetricsContainer = document.getElementById('trade-metrics');
    
    const tradeMetrics = [
        'total_trades', 'winning_trades', 'losing_trades', 'avg_win', 
        'avg_loss', 'largest_win', 'largest_loss', 'avg_trade_duration'
    ];
    
    tradeMetrics.forEach(metric => {
        if (results.metrics[metric] !== undefined) {
            const metricCard = document.createElement('div');
            metricCard.className = 'col-md-3 col-sm-6 mb-3';
            metricCard.innerHTML = `
                <div class="card h-100">
                    <div class="card-body text-center">
                        <h6 class="card-title">${formatMetricName(metric)}</h6>
                        <p class="display-6">${formatMetricValue(metric, results.metrics[metric])}</p>
                    </div>
                </div>
            `;
            tradeMetricsContainer.appendChild(metricCard);
        }
    });
    
    // Populate equity curve chart
    const equityCurveChart = document.getElementById('equity-curve-chart');
    if (results.equity_curve_html) {
        equityCurveChart.innerHTML = results.equity_curve_html;
    } else {
        equityCurveChart.innerHTML = '<p>No equity curve data available.</p>';
    }
    
    // Populate trades table
    const tradesTableBody = document.querySelector('#trades-table tbody');
    
    if (results.trades && results.trades.length > 0) {
        results.trades.forEach(trade => {
            const row = document.createElement('tr');
            
            // Add appropriate class based on trade result
            if (trade.pnl > 0) {
                row.className = 'table-success';
            } else if (trade.pnl < 0) {
                row.className = 'table-danger';
            }
            
            row.innerHTML = `
                <td>${trade.entry_date}</td>
                <td>${trade.exit_date}</td>
                <td>${trade.type}</td>
                <td>${trade.entry_price.toFixed(2)}</td>
                <td>${trade.exit_price.toFixed(2)}</td>
                <td>${trade.size}</td>
                <td>${trade.pnl.toFixed(2)}</td>
                <td>${trade.pnl_percent.toFixed(2)}%</td>
            `;
            
            tradesTableBody.appendChild(row);
        });
    } else {
        tradesTableBody.innerHTML = `
            <tr>
                <td colspan="8" class="text-center">No trades were executed during this backtest.</td>
            </tr>
        `;
    }
    
    // Make results visible and scroll to them
    resultsContainer.style.display = 'block';
    resultsContainer.scrollIntoView({ behavior: 'smooth' });
}

export function initBacktestView() {
    // Set up event listeners
    const backtestForm = document.getElementById('backtest-form');
    if (backtestForm) {
        backtestForm.addEventListener('submit', (e) => {
            e.preventDefault();
            runBacktest();
        });
    }
}
```

#### Step 3.5: Implement OptimizationPanel Module (`modules/optimizationPanel.js`)

```javascript
// frontend/js/modules/optimizationPanel.js
import { optimizeStrategy, checkOptimizationStatus, fetchOptimizationResults } from '../utils/api.js';
import { showError, showSuccessMessage, showLoading, showGlobalLoader, hideGlobalLoader } from '../utils/ui.js';
import { formatMetricName, formatMetricValue, formatParamName } from '../utils/formatters.js';
import { appState } from '../utils/state.js';

export function setupOptimizationParameters() {
    try {
        // Get the strategy parameters container from the strategy tab
        const strategyParamsContainer = document.getElementById('strategy-parameters');
        if (!strategyParamsContainer) {
            throw new Error('Strategy parameters container not found.');
        }
        
        // Get the optimization parameters container
        const optimizationParamsContainer = document.getElementById('optimization-parameters');
        if (!optimizationParamsContainer) {
            throw new Error('Optimization parameters container not found.');
        }
        
        // Clear existing optimization parameters
        optimizationParamsContainer.innerHTML = '';
        
        // Get all parameter inputs from the strategy tab
        const paramInputs = strategyParamsContainer.querySelectorAll('[name]');
        
        // No parameters to optimize
        if (paramInputs.length === 0) {
            optimizationParamsContainer.innerHTML = '<p>No parameters available for optimization.</p>';
            return;
        }
        
        // Create optimization form for each parameter
        paramInputs.forEach(input => {
            const paramName = input.name;
            const formattedName = formatParamName(paramName);
            
            // Create parameter group
            const paramGroup = document.createElement('div');
            paramGroup.className = 'card mb-3';
            
            // Parameter header
            const paramHeader = document.createElement('div');
            paramHeader.className = 'card-header d-flex justify-content-between align-items-center';
            
            // Include checkbox to enable optimization for this parameter
            paramHeader.innerHTML = `
                <h6 class="mb-0">${formattedName}</h6>
                <div class="form-check form-switch">
                    <input class="form-check-input param-optimize-toggle" type="checkbox" id="optimize-${paramName}" data-param="${paramName}">
                    <label class="form-check-label" for="optimize-${paramName}">Optimize</label>
                </div>
            `;
            
            // Parameter body (initially hidden)
            const paramBody = document.createElement('div');
            paramBody.className = 'card-body d-none';
            paramBody.id = `optimize-body-${paramName}`;
            
            // Create different inputs based on parameter type
            if (input.type === 'checkbox') {
                // Boolean parameter - only true/false options
                paramBody.innerHTML = `
                    <p class="text-muted small">This parameter is boolean (true/false) and will be tested with both values.</p>
                `;
            } else if (input.type === 'number') {
                // Numeric parameter - range and step
                paramBody.innerHTML = `
                    <div class="row g-3">
                        <div class="col-md-4">
                            <label class="form-label">Min Value</label>
                            <input type="number" class="form-control" id="min-${paramName}" value="${input.min || 0}">
                        </div>
                        <div class="col-md-4">
                            <label class="form-label">Max Value</label>
                            <input type="number" class="form-control" id="max-${paramName}" value="${input.max || 100}">
                        </div>
                        <div class="col-md-4">
                            <label class="form-label">Step</label>
                            <input type="number" class="form-control" id="step-${paramName}" value="${input.step || 1}">
                        </div>
                    </div>
                `;
            } else if (input.tagName.toLowerCase() === 'select') {
                // Select parameter - all options will be tested
                const options = Array.from(input.options).map(opt => opt.value);
                
                paramBody.innerHTML = `
                    <p class="text-muted small">All options will be tested: ${options.join(', ')}</p>
                `;
            } else {
                // Text or other parameter types - not supported
                paramBody.innerHTML = `
                    <p class="text-muted">This parameter type is not supported for optimization.</p>
                `;
            }
            
            // Append header and body to parameter group
            paramGroup.appendChild(paramHeader);
            paramGroup.appendChild(paramBody);
            
            // Append to container
            optimizationParamsContainer.appendChild(paramGroup);
            
            // Add event listener to toggle optimization options
            const toggleCheckbox = paramGroup.querySelector(`#optimize-${paramName}`);
            toggleCheckbox.addEventListener('change', function() {
                const paramBody = document.getElementById(`optimize-body-${paramName}`);
                if (this.checked) {
                    paramBody.classList.remove('d-none');
                } else {
                    paramBody.classList.add('d-none');
                }
            });
        });
        
    } catch (error) {
        showError(error.message);
    }
}

export async function runOptimization() {
    try {
        showGlobalLoader('Starting optimization...');
        
        // Get form values
        const strategyType = appState.selectedStrategy;
        const startDate = document.getElementById('optimization-start-date').value;
        const endDate = document.getElementById('optimization-end-date').value;
        const initialCapital = parseFloat(document.getElementById('optimization-initial-capital').value);
        const positionSize = parseFloat(document.getElementById('optimization-position-size').value);
        const optimizationMetric = document.getElementById('optimization-metric').value;
        
        // Validate inputs
        if (!strategyType) {
            throw new Error('Please select a strategy first.');
        }
        
        if (!startDate || !endDate) {
            throw new Error('Please provide both start and end dates.');
        }
        
        if (isNaN(initialCapital) || initialCapital <= 0) {
            throw new Error('Initial capital must be a positive number.');
        }
        
        if (isNaN(positionSize) || positionSize <= 0 || positionSize > 100) {
            throw new Error('Position size must be between 0 and 100.');
        }
        
        // Get base strategy parameters (non-optimized values)
        const paramElements = document.querySelectorAll('#strategy-parameters [name]');
        const baseParams = {};
        
        paramElements.forEach(element => {
            const paramName = element.name;
            let paramValue;
            
            if (element.type === 'checkbox') {
                paramValue = element.checked;
            } else if (element.type === 'number') {
                paramValue = parseFloat(element.value);
            } else {
                paramValue = element.value;
            }
            
            baseParams[paramName] = paramValue;
        });
        
        // Get parameters to optimize and their ranges
        const paramOptimizeToggles = document.querySelectorAll('.param-optimize-toggle');
        const paramsToOptimize = {};
        
        let hasOptimizableParams = false;
        
        paramOptimizeToggles.forEach(toggle => {
            if (toggle.checked) {
                const paramName = toggle.dataset.param;
                const paramElement = document.querySelector(`#strategy-parameters [name="${paramName}"]`);
                
                if (paramElement.type === 'checkbox') {
                    // Boolean parameter - test both true and false
                    paramsToOptimize[paramName] = [true, false];
                    hasOptimizableParams = true;
                } else if (paramElement.type === 'number') {
                    // Numeric parameter - use range and step
                    const min = parseFloat(document.getElementById(`min-${paramName}`).value);
                    const max = parseFloat(document.getElementById(`max-${paramName}`).value);
                    const step = parseFloat(document.getElementById(`step-${paramName}`).value);
                    
                    // Validate range
                    if (isNaN(min) || isNaN(max) || isNaN(step)) {
                        throw new Error(`Invalid range for parameter ${formatParamName(paramName)}`);
                    }
                    
                    if (min >= max) {
                        throw new Error(`Min value must be less than max value for ${formatParamName(paramName)}`);
                    }
                    
                    if (step <= 0) {
                        throw new Error(`Step must be positive for ${formatParamName(paramName)}`);
                    }
                    
                    // Generate values array
                    const values = [];
                    for (let value = min; value <= max; value += step) {
                        values.push(Number(value.toFixed(8))); // Fix precision issues
                    }
                    
                    paramsToOptimize[paramName] = values;
                    hasOptimizableParams = true;
                } else if (paramElement.tagName.toLowerCase() === 'select') {
                    // Select parameter - use all options
                    const options = Array.from(paramElement.options).map(opt => opt.value);
                    paramsToOptimize[paramName] = options;
                    hasOptimizableParams = true;
                }
            }
        });
        
        if (!hasOptimizableParams) {
            throw new Error('Please select at least one parameter to optimize.');
        }
        
        // Build request data
        const requestData = {
            strategy_type: strategyType,
            start_date: startDate,
            end_date: endDate,
            initial_capital: initialCapital,
            position_size: positionSize / 100, // Convert percentage to decimal
            optimization_metric: optimizationMetric,
            base_parameters: baseParams,
            optimization_parameters: paramsToOptimize
        };
        
        // Call the API
        const optimizationResponse = await optimizeStrategy(requestData);
        
        // Store the optimization strategy type for status checks
        appState.currentOptimizationStrategy = strategyType;
        
        // Update UI with initial status
        const optimizationStatus = document.getElementById('optimization-status');
        optimizationStatus.innerHTML = `
            <div class="alert alert-info">
                <h5>Optimization Started</h5>
                <p>Job ID: ${optimizationResponse.job_id}</p>
                <p>Status: ${optimizationResponse.status}</p>
                <div class="progress mt-2">
                    <div class="progress-bar progress-bar-striped progress-bar-animated" 
                         role="progressbar" style="width: 0%" 
                         aria-valuenow="0" aria-valuemin="0" aria-valuemax="100">0%</div>
                </div>
            </div>
        `;
        
        // Start polling for status updates
        if (appState.optimizationStatusInterval) {
            clearInterval(appState.optimizationStatusInterval);
        }
        
        appState.optimizationStatusInterval = setInterval(checkOptimizationStatus, 5000);
        
    } catch (error) {
        showError(error.message);
    } finally {
        hideGlobalLoader();
    }
}

export async function checkOptimizationStatus() {
    try {
        // Get status container
        const optimizationStatus = document.getElementById('optimization-status');
        
        // Call the API
        const statusResponse = await checkOptimizationStatus();
        
        // Update progress bar
        const progress = statusResponse.progress || 0;
        const progressBar = optimizationStatus.querySelector('.progress-bar');
        if (progressBar) {
            progressBar.style.width = `${progress}%`;
            progressBar.setAttribute('aria-valuenow', progress);
            progressBar.textContent = `${progress}%`;
        }
        
        // Update status message
        const statusMessage = optimizationStatus.querySelector('p:nth-child(2)');
        if (statusMessage) {
            statusMessage.textContent = `Status: ${statusResponse.status}`;
        }
        
        // If completed, clear interval and fetch results
        if (statusResponse.status === 'completed') {
            if (appState.optimizationStatusInterval) {
                clearInterval(appState.optimizationStatusInterval);
                appState.optimizationStatusInterval = null;
            }
            
            // Wait a moment for the backend to finalize results
            setTimeout(() => {
                fetchAndDisplayOptimizationResults(appState.currentOptimizationStrategy);
            }, 1000);
        }
        
        // If failed, clear interval and show error
        if (statusResponse.status === 'failed') {
            if (appState.optimizationStatusInterval) {
                clearInterval(appState.optimizationStatusInterval);
                appState.optimizationStatusInterval = null;
            }
            
            optimizationStatus.innerHTML = `
                <div class="alert alert-danger">
                    <h5>Optimization Failed</h5>
                    <p>${statusResponse.error || 'An unknown error occurred'}</p>
                </div>
            `;
        }
        
    } catch (error) {
        console.error('Error checking optimization status:', error);
    }
}

export async function fetchAndDisplayOptimizationResults(strategyType) {
    try {
        showGlobalLoader('Fetching optimization results...');
        
        // Call the API
        const results = await fetchOptimizationResults(strategyType);
        
        // Get results container
        const resultsContainer = document.getElementById('optimization-results');
        
        // Clear previous results
        resultsContainer.innerHTML = '';
        
        // Create results card
        const resultsCard = document.createElement('div');
        resultsCard.className = 'card';
        
        // Card header
        const cardHeader = document.createElement('div');
        cardHeader.className = 'card-header';
        cardHeader.innerHTML = `
            <h5 class="card-title mb-0">Optimization Results</h5>
        `;
        
        // Card body
        const cardBody = document.createElement('div');
        cardBody.className = 'card-body';
        
        // Best parameters section
        const bestParamsSection = document.createElement('div');
        bestParamsSection.className = 'mb-4';
        bestParamsSection.innerHTML = `
            <h6>Best Parameters</h6>
            <p class="text-muted small">These parameters produced the best ${formatMetricName(results.optimization_metric)} of ${formatMetricValue(results.optimization_metric, results.best_result[results.optimization_metric])}</p>
        `;
        
        // Create best parameters table
        const bestParamsTable = document.createElement('table');
        bestParamsTable.className = 'table table-sm table-bordered';
        bestParamsTable.innerHTML = `
            <thead>
                <tr>
                    <th>Parameter</th>
                    <th>Value</th>
                </tr>
            </thead>
            <tbody>
            </tbody>
        `;
        
        // Populate best parameters
        const bestParamsTableBody = bestParamsTable.querySelector('tbody');
        Object.entries(results.best_parameters).forEach(([param, value]) => {
            const row = document.createElement('tr');
            row.innerHTML = `
                <td>${formatParamName(param)}</td>
                <td>${value}</td>
            `;
            bestParamsTableBody.appendChild(row);
        });
        
        bestParamsSection.appendChild(bestParamsTable);
        
        // Apply button for best parameters
        const applyBtn = document.createElement('button');
        applyBtn.className = 'btn btn-primary mt-2';
        applyBtn.textContent = 'Apply These Parameters';
        applyBtn.addEventListener('click', () => {
            // Update strategy parameters in the strategy tab
            Object.entries(results.best_parameters).forEach(([param, value]) => {
                const paramInput = document.querySelector(`#strategy-parameters [name="${param}"]`);
                if (paramInput) {
                    if (paramInput.type === 'checkbox') {
                        paramInput.checked = value === true;
                    } else {
                        paramInput.value = value;
                    }
                }
            });
            
            showSuccessMessage('Parameters applied successfully!');
        });
        
        bestParamsSection.appendChild(applyBtn);
        
        // All results section
        const allResultsSection = document.createElement('div');
        allResultsSection.innerHTML = `
            <h6>All Results</h6>
            <p class="text-muted small">Showing top ${results.all_results.length} combinations sorted by ${formatMetricName(results.optimization_metric)}</p>
        `;
        
        // Create results table
        const resultsTable = document.createElement('table');
        resultsTable.className = 'table table-sm table-striped table-hover';
        
        // Create table header
        const tableHeader = document.createElement('thead');
        const headerRow = document.createElement('tr');
        
        // Add header for optimization metric
        const metricHeader = document.createElement('th');
        metricHeader.textContent = formatMetricName(results.optimization_metric);
        headerRow.appendChild(metricHeader);
        
        // Add headers for each parameter
        const firstResult = results.all_results[0];
        Object.keys(firstResult.parameters).forEach(param => {
            const th = document.createElement('th');
            th.textContent = formatParamName(param);
            headerRow.appendChild(th);
        });
        
        tableHeader.appendChild(headerRow);
        resultsTable.appendChild(tableHeader);
        
        // Create table body
        const tableBody = document.createElement('tbody');
        
        // Add rows for each result
        results.all_results.forEach(result => {
            const row = document.createElement('tr');
            
            // Add cell for metric value
            const metricCell = document.createElement('td');
            metricCell.textContent = formatMetricValue(results.optimization_metric, result[results.optimization_metric]);
            row.appendChild(metricCell);
            
            // Add cells for parameter values
            Object.values(result.parameters).forEach(value => {
                const cell = document.createElement('td');
                cell.textContent = value;
                row.appendChild(cell);
            });
            
            tableBody.appendChild(row);
        });
        
        resultsTable.appendChild(tableBody);
        allResultsSection.appendChild(resultsTable);
        
        // Visualization section
        let visualizationSection = '';
        if (results.visualization_html) {
            visualizationSection = document.createElement('div');
            visualizationSection.className = 'mt-4';
            visualizationSection.innerHTML = `
                <h6>Parameter Impact Visualization</h6>
                <div>${results.visualization_html}</div>
            `;
        }
        
        // Append all sections
        cardBody.appendChild(bestParamsSection);
        cardBody.appendChild(allResultsSection);
        if (visualizationSection) {
            cardBody.appendChild(visualizationSection);
        }
        
        // Assemble the card
        resultsCard.appendChild(cardHeader);
        resultsCard.appendChild(cardBody);
        
        // Add to results container
        resultsContainer.appendChild(resultsCard);
        
        // Make visible and scroll to results
        resultsContainer.style.display = 'block';
        resultsContainer.scrollIntoView({ behavior: 'smooth' });
        
    } catch (error) {
        showError(error.message);
    } finally {
        hideGlobalLoader();
    }
}

export function initOptimizationPanel() {
    // Set up event listeners
    const optimizationForm = document.getElementById('optimization-form');
    if (optimizationForm) {
        optimizationForm.addEventListener('submit', (e) => {
            e.preventDefault();
            runOptimization();
        });
    }
    
    // Set up parameters button
    const setupParamsBtn = document.getElementById('setup-optimization-params');
    if (setupParamsBtn) {
        setupParamsBtn.addEventListener('click', setupOptimizationParameters);
    }
    
    // Initially setup optimization parameters
    setupOptimizationParameters();
}
```

#### Step 3.6: Implement SeasonalityAnalyzer Module (`modules/seasonalityAnalyzer.js`)

```javascript
// frontend/js/modules/seasonalityAnalyzer.js
import { runSeasonalityAnalysis } from '../utils/api.js';
import { showError, showSuccessMessage, showGlobalLoader, hideGlobalLoader } from '../utils/ui.js';
import { appState } from '../utils/state.js';

export function initializeSeasonalityControls() {
    // Set up the seasonality type selector
    const seasonalityTypeSelect = document.getElementById('seasonality-type');
    
    if (seasonalityTypeSelect) {
        seasonalityTypeSelect.addEventListener('change', function() {
            // Show/hide specific options based on seasonality type
            const selectedType = this.value;
            
            // Hide all option sections first
            document.querySelectorAll('.seasonality-options').forEach(section => {
                section.classList.add('d-none');
            });
            
            // Show the selected section
            const selectedSection = document.getElementById(`${selectedType}-options`);
            if (selectedSection) {
                selectedSection.classList.remove('d-none');
            }
        });
        
        // Trigger change event to initialize the UI
        seasonalityTypeSelect.dispatchEvent(new Event('change'));
    }
}

export async function runSeasonalityAnalysis() {
    try {
        // Get selected seasonality type
        const seasonalityType = document.getElementById('seasonality-type').value;
        
        if (!seasonalityType) {
            throw new Error('Please select a seasonality analysis type.');
        }
        
        showGlobalLoader('Running seasonality analysis...');
        
        // Get type-specific options
        let options = {};
        
        switch (seasonalityType) {
            case 'day-of-week':
                const dowMetric = document.getElementById('dow-metric').value;
                options = { metric: dowMetric };
                break;
                
            case 'monthly':
                const monthlyMetric = document.getElementById('monthly-metric').value;
                options = { metric: monthlyMetric };
                break;
                
            case 'volatility':
                const volWindow = document.getElementById('volatility-window').value;
                options = { window: parseInt(volWindow) };
                break;
                
            case 'heatmap':
                const heatmapPeriod = document.getElementById('heatmap-period').value;
                const heatmapMetric = document.getElementById('heatmap-metric').value;
                options = { 
                    period: heatmapPeriod,
                    metric: heatmapMetric
                };
                break;
                
            case 'summary':
                // No additional options for summary
                break;
                
            default:
                throw new Error('Invalid seasonality type selected.');
        }
        
        // Call the API with the selected type and options
        const analysisData = {
            type: seasonalityType,
            ...options
        };
        
        const results = await runSeasonalityAnalysis(seasonalityType);
        
        // Display results
        displaySeasonalityResults(seasonalityType, results);
        
    } catch (error) {
        showError(error.message);
    } finally {
        hideGlobalLoader();
    }
}

export function displaySeasonalityResults(type, results) {
    // Get results container
    const resultsContainer = document.getElementById('seasonality-results');
    
    // Clear previous results
    resultsContainer.innerHTML = '';
    
    // Create results card
    const resultsCard = document.createElement('div');
    resultsCard.className = 'card';
    
    // Card header
    const cardHeader = document.createElement('div');
    cardHeader.className = 'card-header';
    cardHeader.innerHTML = `
        <h5 class="card-title mb-0">${getSeasonalityTitle(type)} Analysis Results</h5>
    `;
    
    // Card body
    const cardBody = document.createElement('div');
    cardBody.className = 'card-body';
    
    // Results content based on type
    switch (type) {
        case 'day-of-week':
            if (results.chart_html) {
                cardBody.innerHTML = results.chart_html;
            }
            
            if (results.table_data) {
                cardBody.appendChild(createDataTable(results.table_data, 'Day of Week'));
            }
            break;
            
        case 'monthly':
            if (results.chart_html) {
                cardBody.innerHTML = results.chart_html;
            }
            
            if (results.table_data) {
                cardBody.appendChild(createDataTable(results.table_data, 'Month'));
            }
            break;
            
        case 'volatility':
            if (results.chart_html) {
                cardBody.innerHTML = results.chart_html;
            }
            
            if (results.table_data) {
                cardBody.appendChild(createDataTable(results.table_data, 'Period'));
            }
            break;
            
        case 'heatmap':
            if (results.heatmap_html) {
                cardBody.innerHTML = results.heatmap_html;
            }
            break;
            
        case 'summary':
            // Summary typically has multiple visualizations
            if (results.charts) {
                results.charts.forEach(chart => {
                    const chartSection = document.createElement('div');
                    chartSection.className = 'mb-4';
                    chartSection.innerHTML = `
                        <h6 class="mb-3">${chart.title}</h6>
                        <div>${chart.html}</div>
                    `;
                    cardBody.appendChild(chartSection);
                });
            }
            
            // Summary text
            if (results.summary_text) {
                const summarySection = document.createElement('div');
                summarySection.className = 'alert alert-info mt-3';
                summarySection.innerHTML = `<h6>Analysis Summary</h6>${results.summary_text}`;
                cardBody.appendChild(summarySection);
            }
            break;
            
        default:
            cardBody.innerHTML = '<p>No results available for this analysis type.</p>';
    }
    
    // Add export button if results are available
    if (Object.keys(results).length > 0) {
        const exportButton = document.createElement('button');
        exportButton.className = 'btn btn-secondary mt-3';
        exportButton.textContent = 'Export Results';
        exportButton.addEventListener('click', () => {
            // Implementation for exporting results
            exportSeasonalityResults(type, results);
        });
        
        cardBody.appendChild(exportButton);
    }
    
    // Assemble the card
    resultsCard.appendChild(cardHeader);
    resultsCard.appendChild(cardBody);
    
    // Add to results container
    resultsContainer.appendChild(resultsCard);
    
    // Make visible and scroll to results
    resultsContainer.style.display = 'block';
    resultsContainer.scrollIntoView({ behavior: 'smooth' });
}

// Helper functions
function getSeasonalityTitle(type) {
    const titles = {
        'day-of-week': 'Day of Week',
        'monthly': 'Monthly',
        'volatility': 'Volatility',
        'heatmap': 'Seasonal Heatmap',
        'summary': 'Comprehensive'
    };
    
    return titles[type] || 'Seasonality';
}

function createDataTable(data, keyColumnName) {
    const table = document.createElement('table');
    table.className = 'table table-striped table-bordered mt-3';
    
    // Create table header
    const thead = document.createElement('thead');
    const headerRow = document.createElement('tr');
    
    // Add key column header
    const keyHeader = document.createElement('th');
    keyHeader.textContent = keyColumnName;
    headerRow.appendChild(keyHeader);
    
    // Add value column headers
    Object.keys(data[0]).forEach(key => {
        if (key !== 'key') {
            const th = document.createElement('th');
            th.textContent = key;
            headerRow.appendChild(th);
        }
    });
    
    thead.appendChild(headerRow);
    table.appendChild(thead);
    
    // Create table body
    const tbody = document.createElement('tbody');
    
    // Add rows
    data.forEach(row => {
        const tr = document.createElement('tr');
        
        // Add key cell
        const keyCell = document.createElement('td');
        keyCell.textContent = row.key;
        tr.appendChild(keyCell);
        
        // Add value cells
        Object.entries(row).forEach(([key, value]) => {
            if (key !== 'key') {
                const td = document.createElement('td');
                
                // Format value based on type
                if (typeof value === 'number') {
                    // Format as percentage if needed
                    if (key.includes('return') || key.includes('change')) {
                        td.textContent = `${value.toFixed(2)}%`;
                        
                        // Add color class based on value
                        if (value > 0) {
                            td.className = 'text-success';
                        } else if (value < 0) {
                            td.className = 'text-danger';
                        }
                    } else {
                        td.textContent = value.toFixed(4);
                    }
                } else {
                    td.textContent = value;
                }
                
                tr.appendChild(td);
            }
        });
        
        tbody.appendChild(tr);
    });
    
    table.appendChild(tbody);
    
    return table;
}

function exportSeasonalityResults(type, results) {
    // Create a blob with the JSON data
    const dataStr = JSON.stringify(results, null, 2);
    const blob = new Blob([dataStr], { type: 'application/json' });
    
    // Create a download link
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `seasonality_${type}_results.json`;
    
    // Trigger download
    document.body.appendChild(a);
    a.click();
    
    // Cleanup
    setTimeout(() => {
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    }, 0);
}

export function initSeasonalityAnalyzer() {
    // Initialize controls
    initializeSeasonalityControls();
    
    // Set up event listeners
    const seasonalityForm = document.getElementById('seasonality-form');
    if (seasonalityForm) {
        seasonalityForm.addEventListener('submit', (e) => {
            e.preventDefault();
            runSeasonalityAnalysis();
        });
    }
}
```

#### Step 3.7: Implement ResultsViewer Module (`modules/resultsViewer.js`)

```javascript
// frontend/js/modules/resultsViewer.js
import { compareStrategies } from '../utils/api.js';
import { showError, showSuccessMessage, showGlobalLoader, hideGlobalLoader } from '../utils/ui.js';
import { formatMetricName, formatMetricValue } from '../utils/formatters.js';
import { appState } from '../utils/state.js';

export async function compareStrategiesResults() {
    try {
        // Get selected strategies to compare
        const strategyCheckboxes = document.querySelectorAll('.strategy-checkbox:checked');
        const selectedStrategies = Array.from(strategyCheckboxes).map(cb => cb.value);
        
        if (selectedStrategies.length < 2) {
            throw new Error('Please select at least two strategies to compare.');
        }
        
        showGlobalLoader('Comparing strategies...');
        
        // Call the API
        const results = await compareStrategies({
            strategies: selectedStrategies
        });
        
        // Display results
        displayComparisonResults(results);
        
    } catch (error) {
        showError(error.message);
    } finally {
        hideGlobalLoader();
    }
}

export function displayComparisonResults(results) {
    // Get results container
    const resultsContainer = document.getElementById('comparison-results');
    
    // Clear previous results
    resultsContainer.innerHTML = '';
    
    // Performance comparison chart
    if (results.performance_chart_html) {
        const performanceCard = document.createElement('div');
        performanceCard.className = 'card mb-4';
        performanceCard.innerHTML = `
            <div class="card-header">
                <h5 class="card-title mb-0">Equity Curve Comparison</h5>
            </div>
            <div class="card-body">
                ${results.performance_chart_html}
            </div>
        `;
        resultsContainer.appendChild(performanceCard);
    }
    
    // Metrics comparison table
    if (results.metrics_comparison) {
        const metricsCard = document.createElement('div');
        metricsCard.className = 'card mb-4';
        metricsCard.innerHTML = `
            <div class="card-header">
                <h5 class="card-title mb-0">Performance Metrics Comparison</h5>
            </div>
            <div class="card-body">
                <div class="table-responsive">
                    <table class="table table-striped table-bordered">
                        <thead>
                            <tr>
                                <th>Metric</th>
                                ${results.strategies.map(s => `<th>${s.name}</th>`).join('')}
                            </tr>
                        </thead>
                        <tbody>
                        </tbody>
                    </table>
                </div>
            </div>
        `;
        
        // Add metrics rows
        const metricsTableBody = metricsCard.querySelector('tbody');
        
        // Get all metrics from the first strategy
        const allMetrics = Object.keys(results.metrics_comparison[results.strategies[0].id]);
        
        allMetrics.forEach(metric => {
            const row = document.createElement('tr');
            
            // Add metric name
            const metricNameCell = document.createElement('td');
            metricNameCell.textContent = formatMetricName(metric);
            row.appendChild(metricNameCell);
            
            // Add value for each strategy
            results.strategies.forEach(strategy => {
                const value = results.metrics_comparison[strategy.id][metric];
                const valueCell = document.createElement('td');
                
                valueCell.textContent = formatMetricValue(metric, value);
                
                // Add highlighting for comparison
                if (metric === results.best_metric) {
                    if (value === results.best_values[metric]) {
                        valueCell.className = 'table-success fw-bold';
                    }
                }
                
                row.appendChild(valueCell);
            });
            
            metricsTableBody.appendChild(row);
        });
        
        resultsContainer.appendChild(metricsCard);
    }
    
    // Drawdown comparison chart
    if (results.drawdown_chart_html) {
        const drawdownCard = document.createElement('div');
        drawdownCard.className = 'card mb-4';
        drawdownCard.innerHTML = `
            <div class="card-header">
                <h5 class="card-title mb-0">Drawdown Comparison</h5>
            </div>
            <div class="card-body">
                ${results.drawdown_chart_html}
            </div>
        `;
        resultsContainer.appendChild(drawdownCard);
    }
    
    // Monthly returns comparison
    if (results.monthly_returns_html) {
        const monthlyCard = document.createElement('div');
        monthlyCard.className = 'card mb-4';
        monthlyCard.innerHTML = `
            <div class="card-header">
                <h5 class="card-title mb-0">Monthly Returns Comparison</h5>
            </div>
            <div class="card-body">
                ${results.monthly_returns_html}
            </div>
        `;
        resultsContainer.appendChild(monthlyCard);
    }
    
    // Export button
    const exportButton = document.createElement('button');
    exportButton.className = 'btn btn-primary';
    exportButton.textContent = 'Export Comparison Results';
    exportButton.addEventListener('click', () => {
        exportComparisonResults(results);
    });
    resultsContainer.appendChild(exportButton);
    
    // Make visible and scroll to results
    resultsContainer.style.display = 'block';
    resultsContainer.scrollIntoView({ behavior: 'smooth' });
}

function exportComparisonResults(results) {
    // Create a blob with the JSON data
    const dataStr = JSON.stringify(results, null, 2);
    const blob = new Blob([dataStr], { type: 'application/json' });
    
    // Create a download link
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'strategy_comparison_results.json';
    
    // Trigger download
    document.body.appendChild(a);
    a.click();
    
    // Cleanup
    setTimeout(() => {
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    }, 0);
}

export function initResultsViewer() {
    // Set up compare button
    const compareBtn = document.getElementById('compare-strategies-btn');
    if (compareBtn) {
        compareBtn.addEventListener('click', compareStrategiesResults);
    }
    
    // Set up strategy checkboxes
    updateStrategyCheckboxes();
}

function updateStrategyCheckboxes() {
    // This function would update checkboxes based on available backtest results
    // For the modularization example, we'll leave it as a placeholder
    console.log('Updating strategy checkboxes (to be implemented)');
}
```

#### Step 3.8: Implement ConfigManager Module (`modules/configManager.js`)

```javascript
// frontend/js/modules/configManager.js
import { fetchCurrentConfig, saveConfig } from '../utils/api.js';
import { showError, showSuccessMessage, showGlobalLoader, hideGlobalLoader } from '../utils/ui.js';
import { appState } from '../utils/state.js';

export async function getCurrentConfig() {
    try {
        showGlobalLoader('Loading configuration...');
        
        const config = await fetchCurrentConfig();
        
        // Store in app state
        appState.setCurrentConfig(config);
        
        return config;
    } catch (error) {
        console.error('Error fetching config:', error);
        return {};
    } finally {
        hideGlobalLoader();
    }
}

export async function saveCurrentConfig(configName) {
    try {
        if (!configName) {
            throw new Error('Please provide a name for this configuration.');
        }
        
        showGlobalLoader('Saving configuration...');
        
        // Get current config from state and add name
        const configToSave = {
            ...appState.currentConfig,
            name: configName
        };
        
        // Save to backend
        const response = await saveConfig(configToSave);
        
        showSuccessMessage(`Configuration "${configName}" saved successfully!`);
        
        return response;
    } catch (error) {
        showError(error.message);
    } finally {
        hideGlobalLoader();
    }
}

export function initConfigManager() {
    // Set up save config form
    const saveConfigForm = document.getElementById('save-config-form');
    if (saveConfigForm) {
        saveConfigForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            
            const configNameInput = document.getElementById('config-name');
            const configName = configNameInput.value.trim();
            
            await saveCurrentConfig(configName);
            
            // Clear the input after saving
            configNameInput.value = '';
        });
    }
    
    // Load current config on initialization
    getCurrentConfig();
}
```

#### Checkpoint 3 - Verification
Before proceeding, verify that:
- [ ] All eight feature modules have been implemented
- [ ] Each module correctly imports its dependencies
- [ ] Each module exports necessary functions
- [ ] No circular dependencies exist
- [ ] All related functions from app.js have been moved

### Phase 4: Create Main Entry Point (1-2 days)

#### Step 4.1: Implement `main.js`

```javascript
// frontend/js/main.js
import { appState } from './utils/state.js';
import { activateTab, showError } from './utils/ui.js';
import { checkDataStatus, initDataManager } from './modules/dataManager.js';
import { initIndicatorPanel } from './modules/indicatorPanel.js';
import { initStrategySelector } from './modules/strategySelector.js';
import { initBacktestView } from './modules/backtestView.js';
import { initOptimizationPanel } from './modules/optimizationPanel.js';
import { initSeasonalityAnalyzer } from './modules/seasonalityAnalyzer.js';
import { initResultsViewer } from './modules/resultsViewer.js';
import { initConfigManager, getCurrentConfig } from './modules/configManager.js';

// DOM Element References for tab navigation
const dataTab = document.getElementById('data-tab');
const indicatorsTab = document.getElementById('indicators-tab');
const strategiesTab = document.getElementById('strategies-tab');
const backtestTab = document.getElementById('backtest-tab');
const optimizationTab = document.getElementById('optimization-tab');
const seasonalityTab = document.getElementById('seasonality-tab');
const resultsTab = document.getElementById('results-tab');

const dataSection = document.getElementById('data-section');
const indicatorsSection = document.getElementById('indicators-section');
const strategiesSection = document.getElementById('strategies-section');
const backtestSection = document.getElementById('backtest-section');
const optimizationSection = document.getElementById('optimization-section');
const seasonalitySection = document.getElementById('seasonality-section');
const resultsSection = document.getElementById('results-section');

function initTabNavigation() {
    // Initialize tab navigation
    dataTab.addEventListener('click', (e) => {
        e.preventDefault();
        activateTab(dataTab, dataSection, 'Data Upload');
    });

    indicatorsTab.addEventListener('click', (e) => {
        e.preventDefault();
        if (!appState.dataProcessed) {
            showError('Please upload and process data first.');
            activateTab(dataTab, dataSection, 'Data Upload');
            return;
        }
        activateTab(indicatorsTab, indicatorsSection, 'Technical Indicators');
    });

    strategiesTab.addEventListener('click', (e) => {
        e.preventDefault();
        if (!appState.dataProcessed) {
            showError('Please upload and process data first.');
            activateTab(dataTab, dataSection, 'Data Upload');
            return;
        }
        activateTab(strategiesTab, strategiesSection, 'Trading Strategies');
    });

    backtestTab.addEventListener('click', (e) => {
        e.preventDefault();
        if (!appState.dataProcessed) {
            showError('Please upload and process data first.');
            activateTab(dataTab, dataSection, 'Data Upload');
            return;
        }
        activateTab(backtestTab, backtestSection, 'Backtest');
    });

    optimizationTab.addEventListener('click', (e) => {
        e.preventDefault();
        if (!appState.dataProcessed) {
            showError('Please upload and process data first.');
            activateTab(dataTab, dataSection, 'Data Upload');
            return;
        }
        activateTab(optimizationTab, optimizationSection, 'Strategy Optimization');
    });

    seasonalityTab.addEventListener('click', (e) => {
        e.preventDefault();
        if (!appState.dataProcessed) {
            showError('Please upload and process data first.');
            activateTab(dataTab, dataSection, 'Data Upload');
            return;
        }
        activateTab(seasonalityTab, seasonalitySection, 'Seasonality Analysis');
    });

    resultsTab.addEventListener('click', (e) => {
        e.preventDefault();
        if (!appState.dataProcessed) {
            showError('Please upload and process data first.');
            activateTab(dataTab, dataSection, 'Data Upload');
            return;
        }
        activateTab(resultsTab, resultsSection, 'Analysis Results');
    });
}

// Initialize the application
document.addEventListener('DOMContentLoaded', async () => {
    try {
        console.log("Document loaded, initializing app...");
        
        // Check if data is already processed
        await checkDataStatus();
        
        // Initialize all modules
        initDataManager();
        initIndicatorPanel();
        initStrategySelector();
        initBacktestView();
        initOptimizationPanel();
        initSeasonalityAnalyzer();
        initResultsViewer();
        initConfigManager();
        
        // Initialize tab navigation
        initTabNavigation();
        
        // If data is processed, get current config and update UI
        if (appState.dataProcessed) {
            const config = await getCurrentConfig();
            
            // Update UI components based on the config
            // This would be implemented based on specific needs
        }
        
        // Restore active tab from session storage if available
        const activeTabId = sessionStorage.getItem('activeTab');
        if (activeTabId && appState.dataProcessed) {
            const tabMap = {
                'data-tab': { tab: dataTab, section: dataSection, title: 'Data Upload' },
                'indicators-tab': { tab: indicatorsTab, section: indicatorsSection, title: 'Technical Indicators' },
                'strategies-tab': { tab: strategiesTab, section: strategiesSection, title: 'Trading Strategies' },
                'backtest-tab': { tab: backtestTab, section: backtestSection, title: 'Backtest' },
                'optimization-tab': { tab: optimizationTab, section: optimizationSection, title: 'Strategy Optimization' },
                'seasonality-tab': { tab: seasonalityTab, section: seasonalitySection, title: 'Seasonality Analysis' },
                'results-tab': { tab: resultsTab, section: resultsSection, title: 'Analysis Results' }
            };
            
            if (tabMap[activeTabId]) {
                const { tab, section, title } = tabMap[activeTabId];
                activateTab(tab, section, title);
            }
        } else {
            // Default to first tab
            activateTab(dataTab, dataSection, 'Data Upload');
        }
        
        console.log("App initialization complete");
    } catch (error) {
        console.error("Error initializing app:", error);
    }
});

// Export for shared access
export { appState };
```

### Phase 5: Testing and Integration (7-10 days)

#### Step 5.1: Create a Testing Plan

1. **Unit Testing for Modules**
   - Test each module's core functionality in isolation
   - Verify error handling and edge cases

2. **Integration Testing**
   - Test interactions between modules
   - Verify data flow between frontend and backend

3. **User Interface Testing**
   - Verify all UI elements work correctly
   - Test event handling and user interactions

4. **Test Cases Documentation**
   - Document test cases for each feature
   - Create a test log to track progress

#### Step 5.2: Update HTML to Use the New Modules

```html
<!-- In the index.html file -->
<!-- Replace the original script tag -->
<!-- <script src="frontend/js/app.js"></script> -->

<!-- Add the new module script - use type="module" for ES6 modules -->
<script type="module" src="frontend/js/main.js"></script>
```

#### Step 5.3: Incremental Integration

1. **Start with Utility Modules**
   - Begin by integrating utility modules (api.js, ui.js, etc.)
   - These provide core functionality for all other modules

2. **Add Core Feature Modules**
   - Next integrate dataManager.js as it's required by most other modules
   - Then add indicatorPanel.js and strategySelector.js

3. **Add Complex Feature Modules**
   - Finally integrate backtestView.js, optimizationPanel.js, etc.

4. **Continuously Test**
   - Test functionality after each module is integrated
   - Fix any issues before proceeding to the next module

### Phase 6: Cleanup and Finalization (2-3 days)

#### Step 6.1: Code Cleanup

1. **Remove Debugging Code**
   - Clean up console.log statements used during development
   - Remove any temporary code used for testing

2. **Code Style Consistency**
   - Ensure consistent naming conventions throughout modules
   - Verify consistent formatting (indentation, spacing, etc.)

3. **Documentation**
   - Update comments as needed for clarity
   - Ensure all functions have appropriate JSDoc comments

#### Step 6.2: Performance Review

1. **Identify Bottlenecks**
   - Look for areas where performance could be improved
   - Check for unnecessary API calls or DOM manipulations

2. **Optimize Code**
   - Implement performance improvements as needed
   - Consider lazy-loading for modules that aren't needed immediately

#### Step 6.3: Final Testing

1. **Full Application Test**
   - Test the entire application end-to-end
   - Verify all features work as expected

2. **Cross-Browser Testing**
   - Test in multiple browsers to ensure compatibility
   - Address any browser-specific issues

#### Step 6.4: Deployment

1. **Backup Old Code**
   - Keep a backup of the original app.js for reference
   - This helps in case issues are found later

2. **Deploy New Code**
   - Replace app.js with the modular implementation
   - Update any references to the old code structure

3. **Monitor for Issues**
   - Watch for any issues after deployment
   - Be prepared to address any unexpected problems

## Implementation Timeline

### Week 1: Setup and Utilities
- Days 1-2: Setup directory structure, create skeleton files
- Days 3-5: Implement utility modules (api.js, ui.js, formatters.js, state.js)
- [ ] All feature modules have been implemented
- [ ] No feature functions remain in app.js
- [ ] Each module exports its functions properly
- [ ] No circular dependencies exist between feature modules

### Phase 4: Integration and Testing (1-2 days)

#### Step 4.1: Integrate Modules
Integrate the modules into the existing codebase.

#### Step 4.2: Test the Application
Run comprehensive tests to ensure that all modules work as expected.

#### Step 4.3: Refine and Optimize
Refine the code and optimize performance based on test results.

#### Checkpoint 4 - Verification
Before proceeding, verify that:
- [ ] All modules are integrated correctly
- [ ] The application works as expected
- [ ] Performance is optimized

### Phase 5: Documentation and Deployment (1-2 days)

#### Step 5.1: Document the Implementation
Document the implementation process and results.

#### Step 5.2: Deploy the Application
Deploy the application to the production environment.

#### Checkpoint 5 - Verification
Before proceeding, verify that:
- [ ] All documentation is complete
- [ ] The application is deployed successfully

## Conclusion
This document outlines the detailed step-by-step process for modularizing the monolithic `app.js` file into multiple smaller, maintainable modules. The code will be refactored into a modern, modular JavaScript architecture that improves maintainability, testability, and collaboration.